# 分布式在线商城
该项目是一个面向**服务**的**分布式**的在线商城项目。

# 为什么是分布式的？
因为将不同的服务放置在不同的服务器上能够减少单个服务器的压力。如果服务全都在单个服务器上，当访问人数增加的时候，用户体验会明显下降。
# 为什么是面向服务的？
因为这个项目会涉及很多的服务，服务之间如果不采取面向服务的架构去构建，那么服务之间的依赖就会特别复杂。所以本项目采取面向服务架构。
**面向服务架构的图片**
# 为什么是前后端分离？
减少项目的耦合，提高服务的复用性。

# 项目架构

**项目结构图**

## 前台商城系统
前台的商城系统主要有以下的服务：
1. 商品的搜索服务；
2. 商品的详情介绍服务；
3. 单点登录服务；
4. 购物车服务；
5. 结算服务（&支付服务）；
6. 秒杀服务；
## 后台管理系统
后台管理系统主要有以下的服务：
1. 商品SPU和SKU的管理服务。
2. 订单的物流和库存管理服务。

# 本项目涉及到的技术
Spring Boot，Dubbo，ZooKeeper，Redis，MySQL，ActiveMQ，Kibana，Maven，SSO，Nginx，Tomcat，ElastiSearch，JWT。
接下来会说明各个服务是如何使用各项技术的。

# 服务的详细说明

## 总体介绍
项目的主体使用使用Spring Boot框架搭建的。这个框架减少了编写配置文件的工作，并且能够快速的整合需要的依赖。
使用Dubbo+ZooKeeper的组合来管理各个服务，只需要在服务配置文件中配置好注册中心，服务之间就能够直接调用。

## 商品的搜索服务
该服务主要使用的是ElasticSearch+IK+Kibana。其中IK是ES的中文分词器；Kibana是ES的可视化平台，用来查看ES的情况。
**为什么不适用MySQL数据库的模糊搜索。**
1. MySQL的模糊搜索在特定的情况下不会使用索引，所以搜索速度会慢；
2. 当搜索的请求多了后，由于MySQL不是分布式的，所以用户体验会下降；
**为什么使用ElasticSearch**
1. 这是一个分布式的搜索引擎，能够实现负载均衡，特别适合高并发的场景；
2. 安全性高，当一个节点失效后，并不会导致节点上的数据丢失，因为其它节点有该节点数据的备份；
3. 反向索引，根据value去找key；
**ElasticSearch在该项目中的缺点**
1. MySQL中的数据更新后，需要**手动**将更新后的数据同步到ElastiSearch中；

## 商品的详情介绍服务
这里使用的核心技术是Redis。Redis是一个Key/Value的内存数据库，一般被用来作为数据库（MySQL数据库等）的缓存。因为Redis将数据存放在内存中，读写速度会比一般的数据库快。当用户点击某个商品详情时，如果Redis中未缓存，就会先去数据库中查找，并且存放一份在Redis数据库中。当下次再点击这个商品详情的时候，就能够直接从Redis中获取，速度会比从MySQL中读取快10倍左右。

## 单点登录服务
项目的购物车，结算和支付服务都需要用到用户的登录信息。其中购物车服务可以不需要用户登录就能够使用，但是结算和支付服务**必须**使用用户的登录信息。
这里使用**JWT**来对用户的信息（用户名和密码）进行加密，这样哪怕是用cookie来传递用户的信息也不怕被盗了，同时也方便用户信息在不同模块间的传递。
创建一个拦截器，在用户进入结算或支付模块的时候，检查用户的登录状态，如果用户没有登录就强制跳转到登录界面，要求用户登录，如果用户登录了，就检查当前登录的用户是否与数据库中的一致，一致就执行接下去的步骤。

## 购物车服务
购物车服务会根据用户是否登录来区分对待。如果用户未登录，那用户的“添加购物车”操作会记录在cookie中；如果用户登录了，那么用户的“添加购物车”操作就会记录在数据库中。如果用户登陆后并未进行任何的“添加购物车”操作，那么就会直接从数据库获取之前添加到数据库的商品，并且缓存在Redis中。

## 结算服务（&支付服务）
该服务要求用户登录，在校验了价格和库存后就调用支付宝的结算接口。同时根据支付宝返回的状态码更新订单信息。
这里使用了ActiveMQ消息队列技术对各个服务之间进行解耦。当订单支付成功后就会发出消息，库存服务，订单服务，物流服务等监听到消息队列有新的消息后，就会根据消息的具体内容去执行相应的操作。使用消息队列能够让服务并发进行。
**不使用消息队列**
图
**使用消息队列**
图

## 秒杀服务
在双十一或六一八的时候，淘宝和京东都会开展一些秒杀活动。这里用Redis来实现类似的秒杀服务。在Redis中，能够用“multi”命令来构建事务，用“watch”命令来监视对应key是否发生了改变。在本项目中不仅使用了原生的Redis，还使用Redisson框架，该框架相当于Redis+JUC的组合。
在秒杀服务中，使用Redis和使用Redisson有着不同的表现。Redis的秒杀是随机的，例如说现在有100个商品A，抢购它的用户有10000人，那么并不是前100个先点击抢购的人能够买到商品A，而是随机的，可能后100个点击抢购的人里也有人能够买到商品A。而Redisson是先到先得的，即前100个点击抢购的人一定能够买到商品A。


